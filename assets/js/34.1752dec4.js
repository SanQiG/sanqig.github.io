(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{391:function(t,a,s){"use strict";s.r(a);var e=s(44),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"vdom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vdom"}},[t._v("#")]),t._v(" "),s("a",{attrs:{href:"https://github.com/SanQiG/Front-End-Summary/blob/master/React/VDOM.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("VDOM"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"redux"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" "),s("a",{attrs:{href:"https://github.com/SanQiG/Front-End-Summary/blob/master/React/Redux.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redux"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"vue-和-react-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-react-的区别"}},[t._v("#")]),t._v(" Vue 和 React 的区别")]),t._v(" "),s("p",[t._v("改变数据方式不同，Vue修改状态相比来说要简单的多，React需要使用setState来改变状态，并且使用这个API也有一些坑点。Vue的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是React还是需要用户手动去优化这方面的问题。")]),t._v(" "),s("p",[t._v("React需要使用JSX，Vue使用了模板语法。")]),t._v(" "),s("h2",{attrs:{id:"react-优点是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-优点是什么"}},[t._v("#")]),t._v(" React 优点是什么？")]),t._v(" "),s("ul",[s("li",[t._v("JSX的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的")]),t._v(" "),s("li",[t._v("支持服务器端渲染，可改进SEO和性能")]),t._v(" "),s("li",[t._v("易于测试")]),t._v(" "),s("li",[t._v("React只关注View层，所以可以和其他任何框架（Backbone.js，Angular.js）一起使用")])]),t._v(" "),s("h2",{attrs:{id:"react-生命周期函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-生命周期函数"}},[t._v("#")]),t._v(" React 生命周期函数")]),t._v(" "),s("p",[t._v("React生命周期主要包括三个主要场景：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("装载（Mounting）：组件被插入 DOM 中")])]),t._v(" "),s("li",[s("p",[t._v("更新（Updating）：组件重新渲染以更新 DOM")])]),t._v(" "),s("li",[s("p",[t._v("卸载（Unmounting）：组件从 DOM 中移除")])])]),t._v(" "),s("p",[t._v("不同的场景会调用不同的生命周期方法，包含"),s("code",[t._v("will")]),t._v("的方法在某个时间节点"),s("strong",[t._v("之前")]),t._v("执行，包含"),s("code",[t._v("did")]),t._v("方法在某个时间节点"),s("strong",[t._v("之后")]),t._v("执行。")]),t._v(" "),s("h3",{attrs:{id:"初始渲染-装载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初始渲染-装载"}},[t._v("#")]),t._v(" 初始渲染（装载）")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("生命周期函数")]),t._v(" "),s("th",[t._v("作用")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("strong",[t._v("getDefaultProps")])]),t._v(" "),s("td",[t._v("获取实例的默认属性")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("getInitialState")])]),t._v(" "),s("td",[t._v("获取每个实例的初始化状态")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("componentWillMount")])]),t._v(" "),s("td",[t._v("组件即将被装载、渲染到页面上")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("render")])]),t._v(" "),s("td",[t._v("组件在这里生成虚拟的DOM节点")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("componentDidMount")])]),t._v(" "),s("td",[t._v("组件真正在被装载之后")])])])]),t._v(" "),s("h3",{attrs:{id:"更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更新"}},[t._v("#")]),t._v(" 更新")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("生命周期函数")]),t._v(" "),s("th",[t._v("作用")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("strong",[t._v("componentWillReceiveProps")])]),t._v(" "),s("td",[t._v("组件将要接受到属性的时候调用")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("shouldComponentUpdate")])]),t._v(" "),s("td",[t._v("组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止render调用，后面的函数不会被继续执行了）")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("componentWillUpdate")])]),t._v(" "),s("td",[t._v("组件即将更新不能修改属性和状态")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("render")])]),t._v(" "),s("td",[t._v("组件重新描绘")])]),t._v(" "),s("tr",[s("td",[s("strong",[t._v("componentDidUpdate")])]),t._v(" "),s("td",[t._v("组件已经更新")])])])]),t._v(" "),s("h3",{attrs:{id:"卸载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#卸载"}},[t._v("#")]),t._v(" 卸载")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("生命周期函数")]),t._v(" "),s("th",[t._v("作用")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("strong",[t._v("componentWillUnmount")])]),t._v(" "),s("td",[t._v("组件即将卸载")])])])]),t._v(" "),s("h2",{attrs:{id:"shouldcomponentupdate-nextprops-nextstate-是做什么的-react-性能优化是哪个周期函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate-nextprops-nextstate-是做什么的-react-性能优化是哪个周期函数"}},[t._v("#")]),t._v(" shouldComponentUpdate(nextProps, nextState) 是做什么的（React 性能优化是哪个周期函数）？")]),t._v(" "),s("p",[t._v("当父组件被重新渲染时即render函数执行时，子组件就会默认被重新渲染，但很多时候是不需要重新渲染每一个子组件的。这时就可以使用"),s("code",[t._v("shouldComponentUpdate")]),t._v("来判断是否真的需要重新渲染子组件。仅仅一个判断，就可以节约很多的消耗。所以"),s("strong",[t._v("对于父组件发生变化而子组件不变的情况，使用"),s("code",[t._v("shouldComponentUpdate")]),t._v("会提升性能")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-react extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("shouldComponentUpdate(nextProps, nextState) {\n    if (nextProps.content === this.props.content) {\n        return fasle;\n    } else {\n        return true;\n    }\n}\n")])])]),s("h2",{attrs:{id:"react-生命周期中-最适合与服务器端进行数据交互的是哪个函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-生命周期中-最适合与服务器端进行数据交互的是哪个函数"}},[t._v("#")]),t._v(" React 生命周期中，最适合与服务器端进行数据交互的是哪个函数？")]),t._v(" "),s("p",[s("code",[t._v("componentDidMount")]),t._v("：在这个阶段，"),s("strong",[t._v("实例和DOM已经挂载完成，可以进行相关的DOM操作")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"调用-setstate-之后发生了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调用-setstate-之后发生了什么"}},[t._v("#")]),t._v(" 调用 setState 之后发生了什么？")]),t._v(" "),s("ul",[s("li",[t._v("将传递给setState的对象合并到组件的当前状态，触发所谓的调和（Reconciliation）过程。")]),t._v(" "),s("li",[t._v("然后生成新的元素树和旧的元素树使用Diff算法对比。")]),t._v(" "),s("li",[t._v("根据对比差异对界面进行"),s("strong",[t._v("最小化重渲染")]),t._v("。")])]),t._v(" "),s("p",[t._v("（在差异计算算法中，React能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了"),s("strong",[t._v("按需更新")]),t._v("，而不是全部重新渲染。）")]),t._v(" "),s("h2",{attrs:{id:"setstate-第二个参数的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setstate-第二个参数的作用"}},[t._v("#")]),t._v(" setState 第二个参数的作用")]),t._v(" "),s("p",[s("strong",[t._v("我们可以用该函数来监听渲染是否完成")]),t._v("。因为setState是一个异步的过程，所以说执行完setState之后不能立刻更改state里面的值。如果需要对state数据更改监听，setState提供第二个参数，就是用来监听state里面数据的更改，当数据更改完成，调用回调函数。")]),t._v(" "),s("h2",{attrs:{id:"为什么建议传递给-setstate-的参数是一个-callback-而不是一个对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么建议传递给-setstate-的参数是一个-callback-而不是一个对象"}},[t._v("#")]),t._v(" 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象")]),t._v(" "),s("p",[t._v("setState它是一个异步函数，他会合并多次修改，降低Diff算法的比对频率。这样也会提升性能。")]),t._v(" "),s("p",[t._v("React内部会把JavaScript事件循环中的消息队列的同一个消息中的setState都进行合并以后再重新渲染组件。")]),t._v(" "),s("p",[t._v("因为this.props和this.state的"),s("strong",[t._v("更新是异步的，不能依赖它们的值去计算下一个state")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"react-中-key-的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-中-key-的作用"}},[t._v("#")]),t._v(" React 中 key 的作用")]),t._v(" "),s("p",[t._v("key是React用于追踪那些列表中元素被修改、被添加或者被移除的辅助标识。Diff算法中React会借助元素的key值来判断该元素时新近创建的还是被移动而来的元素，从而减少不必要的元素重新渲染。此外，React还需要借助key值来判断元素与本地状态的关联关系。")]),t._v(" "),s("h2",{attrs:{id:"react-中组件传值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-中组件传值"}},[t._v("#")]),t._v(" React 中组件传值")]),t._v(" "),s("p",[t._v("父传子：父组件定义一个属性，子组件通过this.props接收")]),t._v(" "),s("p",[t._v("子传父：父组件定义一个属性，并将一个回调函数赋值给定义的属性，然后子组件进行调用传过来的函数，并将参数传进去，在父组件的回调函数中即可获得子组件传过来的值。")]),t._v(" "),s("h2",{attrs:{id:"为什么要在-constructor-中绑定事件函数的this指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要在-constructor-中绑定事件函数的this指向"}},[t._v("#")]),t._v(" 为什么要在 constructor 中绑定事件函数的this指向")]),t._v(" "),s("p",[t._v("把一个对象的方法赋值给一个变量会造成this的丢失，所以需要绑定this，把绑定放在构造函数中可以保证只绑定一次函数，如果放在render函数中绑定this的话每次渲染都会去绑定一次this，那样是很耗费性能的。")]),t._v(" "),s("h2",{attrs:{id:"无状态组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无状态组件"}},[t._v("#")]),t._v(" 无状态组件")]),t._v(" "),s("p",[t._v("无状态组件就是使用定义函数的方式来定义组件，这种组件相比于使用类的方式来定义的组件（有状态组件），少了很多初始化过程，更加精简，所以要是可以使用无状态组件应当尽可能的使用无状态组件，会大幅提升效率。")]),t._v(" "),s("h2",{attrs:{id:"react-中-refs-的作用是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-中-refs-的作用是什么"}},[t._v("#")]),t._v(" React 中 refs 的作用是什么？")]),t._v(" "),s("p",[t._v("refs是React提供给我们的安全访问DOM元素或者某个组件实例的API。")]),t._v(" "),s("div",{staticClass:"language-react extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('class CustomForm extends Component {\n    handleSubmit = () => {\n        console.log("Input Value: ", this.input.value);\n    }\n    \n    render() {\n    \treturn (\n        \t<form onSubmit={this.handleSubmit}>\n                <input \n                    type = "text"\n                    ref = {(input) => this.input = input} />\n                <button type="submit">Submit</button>\n            </form>\n        )    \n    }\n}\n')])])]),s("h2",{attrs:{id:"在构造函数中调用-super-props-的目的是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在构造函数中调用-super-props-的目的是什么"}},[t._v("#")]),t._v(" 在构造函数中调用 super(props) 的目的是什么？")]),t._v(" "),s("p",[s("strong",[t._v("在super()被调用之前，子类是不能使用this的，在ES6中，子类必须在constructor中调用super()")]),t._v("。传递props给super()的原因则是便于（在子类中）能在constructor访问this.props。")]),t._v(" "),s("h2",{attrs:{id:"展示组件-presentational-component-和容器组件-container-component-之间有何不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#展示组件-presentational-component-和容器组件-container-component-之间有何不同"}},[t._v("#")]),t._v(" 展示组件（Presentational component）和容器组件（Container component）之间有何不同")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("展示组件关心组件看起来是什么")]),t._v("。")]),t._v(" "),s("p",[t._v("展示专门通过props接收数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心UI状态而不是数据的状态。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("容器组件则更关心组件是如何运作的")]),t._v("。")]),t._v(" "),s("p",[t._v("容器组件会为展示组件或者其他容器组件提供数据和行为，它们会调用Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是（其它组件的）数据源。")])])]),t._v(" "),s("h2",{attrs:{id:"类组件-class-component-和函数式组件-functional-component-之间有何不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类组件-class-component-和函数式组件-functional-component-之间有何不同"}},[t._v("#")]),t._v(" 类组件（Class component）和函数式组件（Functional component）之间有何不同")]),t._v(" "),s("ul",[s("li",[t._v("类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问store并维持状态。")]),t._v(" "),s("li",[t._v("当组件仅是接收props，并将组件自身渲染到页面时，该组件就是一个"),s("code",[t._v("无状态组件")]),t._v("，可以使用一个纯函数来创建这样的组件。")])]),t._v(" "),s("h2",{attrs:{id:"组件的-状态-state-和属性-props-之间有何不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件的-状态-state-和属性-props-之间有何不同"}},[t._v("#")]),t._v(" （组件的）状态（state）和属性（props）之间有何不同")]),t._v(" "),s("ul",[s("li",[t._v("state是一种数据结构，用于组件挂载时所需数据的默认值。state可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。")]),t._v(" "),s("li",[t._v("props则是组件的配置。props由父组件传递给子组件，并且就子组件而言，props是不可变的（immutable）。组件不能改变自身的props，但是可以把其子组件的props放在一起（统一管理）。props也不仅仅是数据，回调函数也可以通过props传递。")])]),t._v(" "),s("h2",{attrs:{id:"react-同构-ssr-时页面加载流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-同构-ssr-时页面加载流程"}},[t._v("#")]),t._v(" React 同构（SSR）时页面加载流程")]),t._v(" "),s("ol",[s("li",[t._v("服务器运行React代码渲染出HTML")]),t._v(" "),s("li",[t._v("浏览器加载这个无交互的HTML代码")]),t._v(" "),s("li",[t._v("浏览器接收到内容展示")]),t._v(" "),s("li",[t._v("浏览器加载JS文件")]),t._v(" "),s("li",[t._v("JS中React代码在浏览器中重新执行")])]),t._v(" "),s("h2",{attrs:{id:"应该在react组件的何处发起ajax请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应该在react组件的何处发起ajax请求"}},[t._v("#")]),t._v(" 应该在React组件的何处发起Ajax请求？")]),t._v(" "),s("p",[t._v("在React组件中，应该在componentDidMount中发起网络请求。这个方法会在组件第一次“挂载”（被添加到DOM）时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前Ajax请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用setState，这将不起作用。")]),t._v(" "),s("h2",{attrs:{id:"何为受控组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#何为受控组件"}},[t._v("#")]),t._v(" 何为受控组件")]),t._v(" "),s("p",[t._v("一个输入表单元素，它的值通过React的这种方式来控制，这样的元素就被称为受控元素。")]),t._v(" "),s("p",[t._v("在HTML中，类似"),s("code",[t._v("<input>")]),t._v("，"),s("code",[t._v("<textarea>")]),t._v("和"),s("code",[t._v("<select>")]),t._v("这样的表单元素会维护自身的状态，并基于用户的输入来更新。但在React中会有些不同，包含表单元素的组件将会在state中追踪输入的值，并且每次调用回调函数时，如onChange会更新state，重新渲染组件。")]),t._v(" "),s("h2",{attrs:{id:"何为高阶组件-hoc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#何为高阶组件-hoc"}},[t._v("#")]),t._v(" 何为高阶组件（HOC）")]),t._v(" "),s("p",[t._v("高阶组件是一个以组件为参数并返回一个新组件的函数。")]),t._v(" "),s("p",[t._v("高阶组件运行你重用代码、逻辑和引导抽象。最常见的可能是Redux的connect函数。除了简单分享工具库和简单的组合，高阶组件最好的方式是共享React组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事，就应该考虑将代码重构为可重用的高阶组件。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("现在如果我想给这个add函数添加一个输出结果的功能，那么你可能会考虑我直接用"),s("code",[t._v("console.log")]),t._v("不就实现了么。说的没错，但是如果我们想做的更加优雅并且容易复用和扩展，我们可以这样去做：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("withLog")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("wrapper")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" wrapper"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" withLogAdd "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("withLog")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("add"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("withLogAdd")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("这个做法在函数式编程里称之为高阶函数，大家都知道React的思想中是存在函数式编程的，高阶组件和高阶函数就是同一个东西。我们实现一个函数，传入一个组件，然后在函数内部再实现一个函数去扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用就是为了更好的复用代码。")]),t._v(" "),s("h2",{attrs:{id:"除了在构造函数中绑定-this-还有其它方式吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#除了在构造函数中绑定-this-还有其它方式吗"}},[t._v("#")]),t._v(" 除了在构造函数中绑定 this ，还有其它方式吗？")]),t._v(" "),s("p",[t._v("你可以使用属性初始值设定项来正确绑定回调，create-react-app也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。")]),t._v(" "),s("h2",{attrs:{id:"怎么阻止组件的渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎么阻止组件的渲染"}},[t._v("#")]),t._v(" 怎么阻止组件的渲染")]),t._v(" "),s("p",[t._v("在组件的render方法中返回null并不会影响触发组件的生命周期方法。")]),t._v(" "),s("h2",{attrs:{id:"react-事件机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-事件机制"}},[t._v("#")]),t._v(" React 事件机制")]),t._v(" "),s("p",[t._v("React其实自己实现了一套事件机制，首先我们考虑一下以下代码：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Test")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" handleClick"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("item"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    \t"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("span onClick"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("handleClick"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("span"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("事实当然不是，JSX上写的事件并没有绑定在对应的真实DOM上，而是通过事件代理的方式，"),s("strong",[t._v("将所有的事件统一绑定在了document上")]),t._v("。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。")]),t._v(" "),s("p",[t._v("另外冒泡到document上的事件也不是原生浏览器事件，而是"),s("strong",[t._v("React自己实现的合成事件（SyntheticEvent）")]),t._v("。因此我们如果不想要事件冒泡的话，调用"),s("code",[t._v("event.stopPropagation")]),t._v("是无效的，而应该调用"),s("code",[t._v("event.preventDefault")]),t._v("。")]),t._v(" "),s("p",[t._v("那么实现合成事件的好处有两点，分别是：")]),t._v(" "),s("ol",[s("li",[t._v("合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力")]),t._v(" "),s("li",[t._v("对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个"),s("em",[t._v("事件池")]),t._v("专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。")])]),t._v(" "),s("h2",{attrs:{id:"createelement和cloneelement有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#createelement和cloneelement有什么区别"}},[t._v("#")]),t._v(" createElement和cloneElement有什么区别？")]),t._v(" "),s("p",[t._v("JSX语法就是用"),s("code",[t._v("React.createElement()")]),t._v("来构建React元素的。它接收三个参数，第一个参数可以是一个标签名。如div、span，或者React组件。第二个参数为传入的属性。第三个及以后的参数，皆作为组件的子组件。")]),t._v(" "),s("div",{staticClass:"language-react extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("React.createElement(\n\ttype,\n    [props],\n    [...children]\n)\n")])])]),s("p",[s("code",[t._v("React.cloneElement()")]),t._v("与"),s("code",[t._v("React.createElement()")]),t._v("相似，不同的是它传入的第一个参数是一个React元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。")]),t._v(" "),s("div",{staticClass:"language-react extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("React.cloneElement(\n\telement,\n    [props],\n    [...children]\n)\n")])])]),s("h2",{attrs:{id:"react中有三种构建组件的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react中有三种构建组件的方式"}},[t._v("#")]),t._v(" React中有三种构建组件的方式")]),t._v(" "),s("p",[s("code",[t._v("React.createClass()")]),t._v("、ES6 class和无状态函数。")]),t._v(" "),s("h2",{attrs:{id:"react组件的划分业务组件和技术组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react组件的划分业务组件和技术组件"}},[t._v("#")]),t._v(" React组件的划分业务组件和技术组件？")]),t._v(" "),s("ul",[s("li",[t._v("根据组件的职责通常把组件分为UI组件和容器组件")]),t._v(" "),s("li",[t._v("UI组件负责UI的呈现，容器组件负责管理数据和逻辑")]),t._v(" "),s("li",[t._v("两者通过React-Redux提供connect方法联系起来")])]),t._v(" "),s("h2",{attrs:{id:"简述flux思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简述flux思想"}},[t._v("#")]),t._v(" 简述Flux思想")]),t._v(" "),s("p",[t._v("Flux的最大特点，就是数据的"),s("strong",[t._v("单向流动")]),t._v("。")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("用户访问View")])]),t._v(" "),s("li",[s("p",[t._v("View发出用户的action")])]),t._v(" "),s("li",[s("p",[t._v("Dispatcher收到Action，要求store进行相应的更新")])]),t._v(" "),s("li",[s("p",[t._v("Store更新后，发出一个“change”事件")])]),t._v(" "),s("li",[s("p",[t._v("View收到“change”事件后，更新页面")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);